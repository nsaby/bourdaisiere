---
title: "TD2026"
author: "Nicolas Saby"
date: "2026-01-07"
output: 
  html_document: 
    toc: true
    highlight: pygments
    theme: flatly
    number_sections: true
---

# La zone du domaine

on tire au hasard dans les strates 4 nouveaux points pour commencer

Pour cela il faut charger les strates en premier lieu

```{r}
# set.seed(110999)
set.seed(3458)

library(terra)
strate <- rast("output/strates.tiff")
crs(strate) <- "+init=epsg:2154"
plot(strate)

```

Lire les anciennes positions des unités d'échantillonnage

```{r}
UE2025 <- vect("output/PointsParc.shp")
# UE2025 <- read_sf("output/PointsParc.shp")

library(tmap)

tm_shape(strate) + tm_raster("clusters") +
  tm_shape(UE2025) + tm_dots()

```

# tirage aléatoire du STSI

Tirer au hasard 4 points par strates

Le plus simple reste d'utiliser la fonction `spatSample`


```{r}

UE2026 <- spatSample(strate[[4]] ,
           size = 10,
           as.points=TRUE,
           method= "stratified")


tm_shape(strate) + 
  tm_raster("clusters" ,
          col.scale = tm_scale_categorical(values = terrain.colors(4)) 
          ) + 
  tm_shape(UE2025) + 
  tm_dots() +
  tm_shape(UE2026) +
  tm_symbols(fill = "clusters",size = .6,
          fill.scale = tm_scale_categorical(n=4)
)

```

Pour assurer une bonne séléction aléatoire des positions, nous allons modifier les coordonnées des centres des pixels sélectionnés dans  un cercle de 7 m

```{r}

mysample <- cbind.data.frame(
  geom(UE2026),
  Strate = UE2026$clusters)

resolution = 7
mysample$x1<-jitter(mysample$x,resolution)
mysample$y1<-jitter(mysample$y,resolution)

```


# Exportation du shape file

```{r}

library(sf)
ptv <- st_as_sf(mysample,
                coords = c("x1","y1") ,
                crs="+init=epsg:2154"
)


st_write(ptv,
                   dsn = "output/EchantDomaine2026.shp",
                   delete_dsn = TRUE
                   )


```


